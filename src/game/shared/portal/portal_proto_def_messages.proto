//====== Copyright 1996-2010, Valve Corporation, All rights reserved. =======
//
// Purpose: The file defines our Google Protocol Buffers which are used to define
//			proto script definition objects' structures.
//
//=============================================================================

// We care more about speed than code size
option optimize_for = SPEED;

// We don't use the service generation functionality
option cc_generic_services = false;


//
// STYLE NOTES:
//
// Use CamelCase CMsgMyMessageName style names for messages.
//
// Use lowercase _ delimited names like my_steam_id for field names, this is non-standard for Steam,
// but plays nice with the Google formatted code generation.
//
// Try not to use required fields ever. Only do so if you are really really sure you'll never want them removed.
// Optional should be preffered as it will make versioning easier and cleaner in the future if someone refactors
// your message and wants to remove or rename fields.
//
// Use fixed64 for JobId_t, GID_t, or SteamID.  This is appropriate for any field that is normally
// going to be larger than 2^56.  Otherwise use int64 for 64 bit values that are frequently smaller
// than 2^56 as it will safe space on the wire in those cases.
//
// Similar to fixed64, use fixed32 for RTime32 or other 32 bit values that are frequently larger than
// 2^28.  It will safe space in those cases, otherwise use int32 which will safe space for smaller values.
// An exception to this rule for RTime32 is if the value will frequently be zero rather than set to an actual
// time.
//
// Note: to make something a key field, list it like so:
// optional	uint32		account_id = 1 [ (key_field) = true ];


import "google/protobuf/descriptor.proto";

extend google.protobuf.MessageOptions
{
    optional bool start_expanded = 80000 [ default = true ];
}

extend google.protobuf.FieldOptions
{
	optional bool editable = 70001 [ default = true ];
	optional bool localized = 70002 [ default = false ];
	optional bool do_not_inherit = 70003 [ default = false ];
	optional string display_name = 70004;
	optional string comment = 70005;
	optional uint32	max_count = 70007;
	optional bool allow_add = 70008 [ default = true ];
	optional bool allow_delete = 70009 [ default = true ];
	optional string panel_class_override = 70010;
	optional string message_inherhitance_key_field_name = 70011; // If the empty string, just append.  If not, try to find any repeated fields
																// in the derived message that has a matching key field
	optional bool inherit_reference_variables = 70012 [ default = false ];
	optional bool self_inherit_only = 70013 [ default = false ];
	optional EVarFieldType var_field_type = 70014 [ default = VAR_TYPE_INVALID ];
	optional bool merging_key_field = 70015 [ default = false ];
}

enum LogicalOperation
{
	AND = 0;
	OR = 1;
	NOT = 2;
};


// A reference to a field that might be within a nested message
message CMsgFieldID
{
	// A reference to a field
	message CMsgField
	{
		optional uint32 field_number = 1;
		optional uint32 repeated_index = 2; // This is ignored for non-repeated fields
	}

	repeated CMsgField field = 1; // Starting in the defining message body scope
}

enum EValueDefinitionSource
{
	REFERENCE_DEFINES = 0;
	PARENT_DEFINES = 1;
	THIS_DEFINES = 2;
	VARIABLE_DEFINES = 3;
	NOT_DEFINED = 4; // The default value is used
};

message CMsgUniversalFieldID
{
	optional EValueDefinitionSource	source_type		= 1; // Which type is defining us
	optional CMsgProtoDefID			defining_obj_id	= 2; // Which object defined the value
	optional CMsgFieldID			field_id		= 3; // From which field ID within the object
}

message CMsgVariableDefinition
{
	optional string			name		= 1 [ (merging_key_field) = true ];
	optional bool			inherit		= 2 [ default = true ];
	optional string			value		= 3;
}

message CMsgProtoDefHeader
{
	required uint32						defindex				= 1 [ (editable) = false,
																	  (self_inherit_only) = true,
																	  (display_name) = "Defindex",
																	  (comment) = "Autogenerated" ];

	optional string						name					= 2 [ (self_inherit_only)	= true,
																	  (display_name)		= "Name",
																	  (comment)				= "Name to show in the editor" ];

	repeated CMsgProtoDefID				prefabs					= 3 [ (self_inherit_only)	= true,
																	  (display_name)		= "Prefab",
																	  (panel_class_override) = "CPrefabFieldEditingPanel",
																	  (comment)				= "Inherit the values of these definitions, in order from top to bottom." ];

	repeated string						tags					= 4 [ (display_name)		= "Tags",
																	  (comment)				= "Strings used to describe this definition while searching.  ie. 'class', 'shotgun', 'easy'" ];

	optional bool						prefab_only				= 5 [ (self_inherit_only)	= true,
																	  default				= false,
																	  (display_name)		= "Pure Prefab",
																	  (comment)				= "If true, this is only a prefab and will not be made into an object" ];

	repeated CMsgVariableDefinition		variables				= 6 [ (message_inherhitance_key_field_name) = "name",
																	  (display_name)		= "Variables",
																	  (comment)				= "Variable value definitions" ];


}

message CMsgProtoDefID
{
	optional uint32 defindex = 1;

	oneof instance
	{
		CMsgQuestMapNodeDef			instance_def_type_quest_map_node = 3;
		CMsgQuestTheme				instance_def_type_quest_theme = 5;
		CMsgQuestMapRegionDef		instance_def_type_quest_map_region = 6;
		CMsgQuestDef				instance_def_type_quest = 7;
		CMsgQuestObjectiveDef		instance_def_type_quest_objective = 8;
		CMsgHeaderOnly				instance_def_type_header_only = 13;
	}
}

message CMsgQuestObjectiveDef
{
	enum ETF2GameModes
	{
	kGameCategory_2Player	= 0,
	kGameCategory_2Player_Rexaura,
	kGameCategory_3Player,
	
	kGameCategory_Quickplay,
	};

	required	CMsgProtoDefHeader	header				= 1;
	optional	string				loc_desctoken		= 2 [ (localized) = true ];
	optional	uint32				points				= 3;
	optional	uint32				conditions_defindex = 5;
	repeated	string				map = 8				[ (display_name)	= "Maps Modifier"
														, (comment)			= "If set, the player must be on one of the listed maps to get credit." ];
	repeated	ETF2GameModes		game_mode = 9		[ (display_name)	= "Game Mode Modifier"
														, (comment)			= "If set, the player must be in one of the listed game modes to get credit." ];
	optional	ETF2Team			team = 10			[ (display_name)	= "Team Modifier"
														, (comment)			= "If set, the player must be on the specified team to get credit." ];

	repeated	CMsgVarField		condition_vars		= 11 [ (var_field_type) = VAR_TYPE_STRING, (display_name) = "Objective Vars" ];
	repeated	CMsgVarField		classes_vars		= 12 [ (var_field_type) = VAR_TYPE_STRING, (display_name) = "Class Modifier" ];
	repeated	string				item_name			= 15 [ (display_name) = "Required equipped item", (comment) = "Require that this item be equipped in any slot." ];
	optional	uint32				jump_state			= 17 [ (display_name) = "Jump logic", (comment) = "What state of jumping the player needs to be in." ];
}

message CMsgQuestDef
{
	message MMCriteria
	{
		optional	string	group_name = 1;
		optional	string	category_name = 2;
		optional	string	map_name = 3;
	}

	message ObjectiveInstance
	{
		optional CMsgProtoDefID objective = 1 [ (valid_type) = DEF_TYPE_QUEST_OBJECTIVE ];
		optional uint32			point_value = 3 [ (display_name) = "Points Override", (comment) = "Override value for the point value of the objective.  If not set, uses the objective's point value" ];
	}

	required	CMsgProtoDefHeader	header				= 1;
	optional	uint32				max_points_0		= 2;
	optional	uint32				max_points_1		= 3;
	optional	uint32				max_points_2		= 4;
	optional	string				name_loctoken		= 5 [ (localized) = true ];
	optional	string				operation			= 7;
	optional	MMCriteria			mm_criteria			= 8;
	optional	string				node_image			= 12 [ (display_name) = "Node Image", (comment) = "Filename of the image to show on the node view" ];
	optional	string				icon_image			= 13 [ (display_name) = "Node Icon", (comment) = "Which icon to show on the map" ];
	optional	CMsgProtoDefID		theme				= 14 [ (valid_type) = DEF_TYPE_QUEST_THEME ];	// Which theme to use
	repeated	string				loaner_names		= 15 [ (display_name) = "Loaners", (comment) = "Names of items to give as loaners" ];
	repeated	ObjectiveInstance	objectives			= 16;
	repeated	string				map					= 17 [ (display_name)	= "Maps Modifier", (comment) = "If set, the player must be on one of the listed maps to get credit." ];
}

message CMsgQuestMapStoreItem
{
	required	CMsgProtoDefHeader	header					= 1;
	optional	string				item_name				= 2;	// Item name
	optional	string				reward_lootlist_name	= 6 [ (display_name) = "Reward Lootlist", (comment) = "The name of the lootlist to roll as a reward" ];
	optional	CMsgVarField		price					= 3 [ (var_field_type) = VAR_TYPE_SINT32 ];
	optional	uint32				purchase_limit			= 4 [ (display_name) = "Purchase Limit", (comment) = "How many times this reward can be purchased" ]; 
	optional	uint32				sort_group				= 5 [ (display_name) = "Sort group", (comment) = "Sort by this group, then alhpabetically" ];
}

message CMsgQuestMapRegionDef
{
	message RegionLink
	{
		required CMsgProtoDefID		target_region_defid	= 1 [ (valid_type) = DEF_TYPE_QUEST_MAP_REGION ];	// Which region this link references
		optional uint32				xpos				= 2;
		optional uint32				ypos				= 3;
	}

	required CMsgProtoDefHeader header		= 1;
	optional string				name		= 2 [ (localized) = true ];
	optional string				resfile		= 3;
	repeated RegionLink			links		= 4;
	optional CMsgProtoDefID		return_link = 5 [ (valid_type) = DEF_TYPE_QUEST_MAP_REGION, (display_name) = "Return Link", (comment) = "Which link we go to when right-clicking in this region" ];
	optional float				radio_freq	= 6 [ (display_name) = "Radio Freq.", (comment) = "Where the radio tuner goes on the CYOA PDA when this region is selection" ];
	optional float				zoom_scale	= 7 [ (display_name) = "Zoom Scale", (comment) = "How zoomed in this panel should be.  Affects the scale of the map grid lines and node link dashed lines" ];
	optional CMsgProtoDefID		star_type  = 8 [ (valid_type) = DEF_TYPE_QUEST_MAP_STAR_TYPE, (display_name) = "Star Type", (comment) = "What stars (if any) the nodes within use to unlock" ];
}

enum EVarFieldType
{
	VAR_TYPE_INVALID = 1;
	VAR_TYPE_FLOAT	= 2;
	VAR_TYPE_DOUBLE	= 3;
	VAR_TYPE_UINT32	= 4;
	VAR_TYPE_UINT64	= 5;
	VAR_TYPE_SINT32	= 6;
	VAR_TYPE_SINT64	= 7;
	VAR_TYPE_BOOL	= 8;
	VAR_TYPE_STRING	= 9;
}

message CMsgVarField
{
	optional string variable = 1 [ (merging_key_field) = true ];

	oneof value
	{
		float	float	= 2;
		double	double	= 3;
		uint32	uint32	= 4;
		uint64	uint64	= 5;
		sint32	sint32	= 6;
		sint64	sint64	= 7;
		bool	bool	= 8;
		string	string	= 9;
	}
}

message CMsgQuestMapStarType
{
	required	CMsgProtoDefHeader	header		= 1;
	optional	string				name		= 2 [ (localized) = true, (display_name) = "Type Name" ];
}

message CMsgQuestMapNodeDef
{
	required	CMsgProtoDefHeader			header				= 1;
	optional	string						name_loctoken		= 4 [ (localized) = true, (display_name) = "Node Name", (comment) = "The name of this node" ];
	optional	float						x_pos				= 6 [ (display_name) = "Map X Pos", (comment) = "X position on the quest map" ];
	optional	float						y_pos				= 7 [ (display_name) = "Map Y Pos", (comment) = "Y position on the quest map" ];
	optional	CMsgQuestMapNodeCondition	condition			= 9 [ (display_name) = "Conditions", (comment) = "Logic to unlock this node. Can be nested with logic" ];
	optional	CMsgProtoDefID				owning_region		= 10 [ (valid_type) = DEF_TYPE_QUEST_MAP_REGION , (display_name) = "Region", (comment) = "Which region in the map this node shows up in" ];
	repeated	CMsgProtoDefID				quest_options		= 11 [ (valid_type) = DEF_TYPE_QUEST, (display_name) = "Offered Quests", (comment) = "Which quests this node offers.", (max_count) = 3 ];
	optional	string						associated_operation= 16 [ (display_name) = "Associated Operation", (comment) = "Operation this node is associated with" ];
	optional	string						reward_item_name	= 18 [ (display_name) = "Reward Item", (comment) = "The name of an item to give as a reward" ];
	optional	string						reward_lootlist_name= 22 [ (display_name) = "Reward Lootlist", (comment) = "The name of the lootlist to roll as a reward" ];
	optional	CMsgProtoDefID				star_type			= 20 [ (valid_type) = DEF_TYPE_QUEST_MAP_STAR_TYPE, (display_name) = "Star Type", (comment) = "Which type of star this node uses" ];
	optional	uint32						stars_to_unlock		= 21 [ default = 1, (display_name) = "Stars to Unlock", (comment) = "Numbers of stars it costs to unlock" ];
}

message CMsgQuestTheme
{
	message WeightedString
	{
		optional string string = 1;
		optional uint32 weight = 2;
	}

	message WeightedStringSet
	{
		repeated WeightedString weighted_strings = 1;
	}

	required	CMsgProtoDefHeader	header	= 1;

	optional string notification_res = 2;
	optional string quest_item_res = 3;
	optional string in_game_tracker_res = 4;

	// Sounds
	repeated WeightedStringSet give_sounds = 5;
	repeated WeightedStringSet complete_sounds = 6;
	repeated WeightedStringSet fully_complete_sounds = 7;
	optional string reward_sound = 8;
	optional string discard_sound = 9;
	optional string reveal_sound = 10;
}

message CMsgQuestMapNodeCondition_NodeState
{
	optional uint32 bonus_objectives_required = 1 [ default = 0, (display_name) = "Bonus Required", (comment) = "Number of bonus objectives required, on top of the primary objective" ];
	required CMsgProtoDefID				target_node_defid	= 2 [ (valid_type) = DEF_TYPE_QUEST_MAP_NODE, (display_name) = "Target Node", (comment) = "Which node is required to have the above number of medals" ];	
}

message CMsgQuestMapNodeCondition_Logic
{
	required LogicalOperation	operation		= 1 [ (display_name) = "Logic", (comment) = "Logical operation" ];
	repeated CMsgQuestMapNodeCondition sub_conditions	= 2 [ (display_name) = "Operands", (comment) = "Definitions to use in the logical operation" ];
}

message CMsgQuestMapNodeCondition
{
	oneof operation
	{
		CMsgQuestMapNodeCondition_NodeState node_state = 1 [ (display_name) = "Node State Condition", (comment) = "Returns true if a specific node has a required number of medals" ];
		CMsgQuestMapNodeCondition_Logic logical = 2 [ (display_name) = "Logical Condition", (comment) = "Performs a specified logical operation to all sub conditions" ];
	}
}

message CMsgHeaderOnly
{
	required	CMsgProtoDefHeader	header	= 1;
}

// End of File
